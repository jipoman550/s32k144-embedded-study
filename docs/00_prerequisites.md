## 1. 이 문서의 목적

- 아직 임베디드를 모르는 완전 초보가 S32K144EVB 기반 프로젝트를 시작하기 전에 반드시 이해해야 할 최소한의 배경지식을 제공하는 문서임.
- 다른 docs/ 파일들을 이해하기 위한 “전제조건” 역할.

---

## 2 필수 컴퓨터 기초

임베디드의 핵심은 **하드웨어가 어떻게 동작하는지** + **C 코드가 하드웨어를 어떻게 제어하는지** 이 두 가지다.

따라서 다음 개념들이 필요함:

### ✓ 비트와 바이트

#### 8-bit / 16-bit / 32-bit 차이

임베디드 프로그래밍(특히 C언어)에서는 `int`나 `long` 같이 컴파일러에 따라 크기가 달라질 수 있는 애매한 표현 대신, **`<stdint.h>`에 정의된 크기가 명시된 자료형**을 사용하는 것이 원칙이다. 이는 하드웨어 레지스터의 크기와 변수의 크기를 정확히 일치시켜야 하기 때문이다.

**데이터 크기와 표현 범위**

S32K144는 **32-bit MCU**이다. 이는 CPU가 한 번에 처리하는 데이터의 크기와 레지스터의 크기가 **32비트(4바이트)**라는 뜻이다.

* **8-bit (`uint8_t`)**
    * **크기:** 1 Byte
    * **범위:** 0 ~ 255 ($2^8 - 1$)
    * **용도:** 문자 데이터(`char`), 통신 버퍼(UART/SPI)의 한 바이트, 작은 상태 플래그 값.
* **16-bit (`uint16_t`)**
    * **크기:** 2 Byte
    * **범위:** 0 ~ 65,535 ($2^{16} - 1$)
    * **용도:** PWM 주기 값, ADC 변환 값(보통 10~12비트 해상도이므로 16비트에 담음).
* **32-bit (`uint32_t`)**
    * **크기:** 4 Byte
    * **범위:** 0 ~ 4,294,967,295 ($2^{32} - 1$)
    * **용도:** **S32K144의 레지스터 값**, 메모리 주소(포인터), 타이머의 전체 카운트 값.

> **💡 핵심**
> S32K144의 레지스터는 대부분 **32비트**이다. 따라서 레지스터 값을 읽거나 쓸 때는 주로 `uint32_t` 변수를 사용해야 데이터 손실 없이 정확하게 제어할 수 있다.

#### 비트마스킹(AND, OR, SHIFT)

MCU 제어의 핵심은 **"32개의 전구(비트) 중 내가 원하는 전구 하나만 끄거나 켜는 것"**이다. 이를 위해 사용하는 기법이 바로 비트마스킹이다.

**1. SHIFT 연산 (`<<`, `>>`) : 위치 이동**

비트를 원하는 위치로 이동시킨다. 주로 **"몇 번째 비트를 건드릴 것인가"**를 지정할 때 사용한다.
* `1 << n`: 1이라는 값을 왼쪽으로 n칸 이동시킨다. (n번째 비트만 1이 됨)

```c
(1 << 0)   // 0000 0001 (0번 비트)
(1 << 3)   // 0000 1000 (3번 비트)
(1 << 12)  // 12번 비트만 1, 나머지는 0
````

**2. OR 연산 (`|`) : 특정 비트 켜기 (Set)**

이미 켜져 있는 비트는 건드리지 않고, **내가 원하는 비트만 강제로 1로 만들 때** 사용한다.

  * **논리:** 0과 1이 만나면 1이 되고, 1과 1이 만나도 1이 된다. (덧칠하기 개념)
  * **공식:** `레지스터 |= (1 << 핀번호);`

<!-- end list -->

```c
// 예시: GPIOA의 12번 핀을 1로 만들기 (Set)
// 기존값: 0000 ... 0000 (가정)
// 마스크: 0000 ... 1000 (1 << 12)
// 결과 : 0000 ... 1000 (12번 비트가 켜짐)

GPIOA->PDDR |= (1 << 12);
// 해석: GPIOA의 PDDR 레지스터의 기존 값은 유지하되, 12번째 비트만 '1'로 설정하라.
```

**3. AND 연산 (`&`) : 특정 비트 확인 또는 끄기**
두 가지 용도로 사용된다.

**(1) 확인 (Check / Read)**

특정 비트가 1인지 0인지 검사할 때 사용한다.

  * **논리:** 둘 다 1일 때만 1이 된다.

<!-- end list -->

```c
// 예시: 버튼이 연결된 3번 비트가 1인지 확인
if (GPIOA->PDIR & (1 << 3)) {
    // 3번 비트가 1이라면(눌렸다면) 이 안의 코드를 실행
}
```

**(2) 끄기 (Clear) - 중요\!**

특정 비트를 0으로 만들려면 \*\*"그 위치만 0이고 나머지는 1인 마스크"\*\*와 AND 연산을 해야 한다. 이때 `~`(NOT) 연산자를 사용한다.

  * `~ (1 << 3)` : `0000 1000`을 뒤집어서 `1111 0111`로 만든다.
  * **공식:** `레지스터 &= ~(1 << 핀번호);`

<!-- end list -->

```c
// 예시: 12번째 비트 끄기
GPIOA->PDDR &= ~(1 << 12);
// 해석: 12번째 비트만 0으로 만들고(끄고), 나머지 비트는 원래 값 그대로 둬라.
```

> **📝 비트마스킹 3대 공식 요약**
>
> 1.  **켜기 (Set):** `REG |= (1 << n);`
> 2.  **끄기 (Clear):** `REG &= ~(1 << n);`
> 3.  **확인 (Check):** `if (REG & (1 << n))`

### ✓ 메모리 개념

- ROM(Flash) vs RAM(SRAM)
- 스택 vs 힙
- 포인터가 중요한 이유

### ✓ C 기초

너는 이미 프로그래머니까 가능하겠지만

임베디드에서는 특히 아래가 중요함:

- 구조체(struct)
- 비트필드
- 포인터
- volatile의 의미
- static의 의미(파일/함수 레벨)
- 함수 포인터(인터럽트 테이블 때문에)

---

## 3 MCU 기본 개념

본격적인 주변장치를 배우기 전에 알아야 하는 최소 MCU 개념들.

### ✓ MCU란 무엇인가

- CPU + Flash + SRAM + Peripherals가 한 칩
- S32K144는 ARM Cortex-M4 기반의 자동차용 MCU

### ✓ 주변장치(Peripheral)의 개념

- GPIO
- Timer
- UART
- PWM
- ADC
- CAN

→ 모두 레지스터로 제어한다는 점이 중요.

### ✓ 레지스터(register) 개념

레퍼런스 매뉴얼을 읽기 위한 가장 중요한 사전 지식.

- 주변장치 제어 = 레지스터 설정
- 32-bit 값 하나로 주변장치 상태가 바뀜
- 비트 필드를 통해 구성됨

예시:

```c
GPIOA->PDDR |= (1 << 12);  // A12핀을 출력으로 설정

```

---

## 4 ARM Cortex-M 개념

완전 초보가 반드시 알고 있어야 하는 기본 구조

- 레지스터(PC, SP, R0~R12 등)
- NVIC(Interrupt Controller)
- 스택 구조
- 인터럽트 우선순위
- Exception vs Interrupt

이건 S32K144 레퍼런스 매뉴얼을 이해하는 데 필수다.

---

## 5 S32K144EVB를 다루기 위한 기초

NXP 환경을 배우기 전에 알아야 하는 것들.

### ✓ S32DS(S32 Design Studio)

- Eclipse 기반 IDE
- 프로젝트 생성 방식
- SDK + Processor Expert + ConfigTools의 차이

### ✓ Board schematic 보는 법

- LED 핀
- 버튼 핀
- 디버그/UART 핀
- 전원 구조

### ✓ Datasheet vs Reference Manual

두 문서는 역할이 다르다.

- **Datasheet**: MCU 핀 구조, 전기적 특성
- **Reference Manual**: 주변장치 동작 원리, 레지스터 설명

---

## 6 빌드/플래시/디버깅 기초

보드를 쓰려면 아래 이해 필요.

### ✓ 컴파일 → 링크 → 플래시 과정

- ELF
- HEX
- Linker script(링커스크립트)의 역할

### ✓ 디버거 사용 OpenSDA

- Breakpoint
- Step-in / Step-out
- 변수 Watch
- 레지스터 창 보기

이건 실습 중 필수다.

---

## 7 이 문서를 읽은 후 할 수 있어야 할 것

- Datasheet에서 핀 이름을 찾을 수 있다
- Reference Manual의 레지스터 구조를 읽을 수 있다
- GPIO 레지스터의 “한 비트”가 어떤 의미인지 이해할 수 있다
- SDK가 레지스터를 추상화한다는 것을 이해한다
- S32DS에서 프로젝트 생성 → 빌드 → 디버깅 가능